{% include head.html %}

# MIPS アセンブリ言語入門

ここから先はだんだんハードウェアに近い話が見えてくるので，ここでターゲット言語の MIPS アセンブリ言語について少し勉強しよう．本節では，MIPS アセンブリ言語でプログラムを実際に書いて，その動作を確認する．MIPS アーキテクチャについては[いわゆるパタヘネ本の和訳](https://www.nikkeibp.co.jp/atclpubmkt/book/yy/121400008/)を読まれたい．（買って読んで損はない本である．）

本節の内容は MIPS に詳しい人から見ると不十分だったり不正確だったりする部分が多いかもしれない．改善のための提案には Issue を立ててもらうとありがたい．

ところで，自分が普段使っているマシンで MIPS のコードが直接動く人は多分いない．したがって，本節の内容を実行するには，MIPS のコードを動かすためのシミュレータが欲しい．そのようなシミュレータとして一番お手軽なのは[SPIM](http://spimsimulator.sourceforge.net/)である．これをインストールして使ってもよいのだが，ここでは[ymyzk氏](https://www.ymyzk.com/)による拡張[spim-for-kuis](https://github.com/ymyzk/spim-for-kuis)を勧める．インストール方法は[spim-for-kuis](https://github.com/ymyzk/spim-for-kuis)のページを参照されたい．以下の例も spim-for-kuis での実行例である．

## 例1: レジスタに即値をロードして標準出力に出力する

まずはシンプルなプログラムから見てみよう．以下のプログラムを`ex01.s`として保存して`spim -file ex01.s`を実行してみてほしい．spim-for-kuis が入っていれば，`spim -show_stats -show_instructions -file ex01.s` を実行すると，実行された命令と命令数に関する統計情報が出力される．（ARMアセンブリ言語のためのハイライティングしか用意されていなかったので一部構文エラーの警告らしきハイライトが出ているが気にしないこと．）

{% highlight armasm %}
{% include_relative mips/ex01.s %}
{% endhighlight %}

MIPS アセンブリのプログラムでは，各行に以下のいずれかが書かれている．

- 命令: 上の例では `addiu $sp,$sp,-20` のような行は命令である．`$sp`や`-20`等は命令の引数である．命令を実行すると，レジスタやメモリへ情報が読み書きされたり，次に実行する命令が決まったりする．
- ラベル: 上の例では `main:` のような行がラベルである．ラベルはアセンブリ中での場所を表している．次に実行すべき命令を指定するジャンプ命令はラベル名を用いてプログラムのどこにジャンプすべきかを決定することができる．アセンブラによってアセンブリプログラムが機械語に変換されるときには，データや各命令があらかじめ定められた仕様にしたがってバイナリに変換されるが，このときに各命令にもアドレスが付番される．各ラベルはこの変換後のアドレスに変換されてバイナリ中で使われる．（プログラム中の場所にも最終的にアドレスが振られるのだ，ということに注意しておいてほしい．）
- ディレクティブ: `.text` のようにドットで始まる行はディレクティブと呼ばれる．ディレクティブはアセンブリ中のどこにプログラムが書かれているか，どこにデータが書かれているか，このプログラム中でのグローバル関数名はどれかなどの情報をアセンブラに伝える役割がある．この講義の範囲では，深入りせずにおまじないと思っておいてもよい．

一行ずつ内容を説明しよう．

- `.text`: 以降にプログラムが書かれていることを示すディレクティブである．
- `.globl main`: `main` がグローバル関数 `main` の開始場所を表すラベルであることを示すディレクティブである．
- `main:`: ここから関数 `main` の定義が始まることを示すラベルである．
- `addiu  $sp,$sp,-20`: 第1引数 `$sp` に第2引数 `$sp` と第3引数 `-20` の和を書き込む命令である．`$`で始まる名前（例えば`$sp`）は _レジスタ (register)_ と呼ばれる記憶領域を表しており，メモリに比べて数が限られているが読み書きが高速にできる．`$sp` は _スタックポインタ (stack pointer)_ と呼ばれる特別なポインタを保存するためのレジスタである．これについては関数呼び出しの節で詳しく説明するが，ここでは`$sp` の値は (1) 関数定義の先頭で （関数本体によって決まる）一定量減らされ，(2) 関数から戻る前に同じ量だけ増やされる（したがって関数から戻った後の `$sp` の値は関数が呼び出されたときの値と同じである）ことを覚えておいてほしい．
- `li $v0,1`: レジスタ `$v0` に整数定数 `1` を書き込む命令である．アセンブリの文脈では定数のことを _即値 (immediate)_ と呼ぶことが多い．命令 `li` は load immediate から来ているんだと思う．
- `li $a0,20`: 同様にレジスタ `$a0` に即値 `20` を書き込む命令である．
- `syscall`: _システムコール (system call)_ を発行する命令である．`syscall` 命令は標準入出力の操作等を行うための命令で，命令実行時のレジスタ `$a0` とレジスタ `$v0` の値に応じて挙動が変わる．レジスタ `$v0` に `1` がセットされている状態で `syscall` を呼び出すと，標準出力にレジスタ `$a0` の値（すなわちここでは `20`）が出力される．
- `addiu   $sp,$sp,20`: 上で説明したように，関数から返る前に `$sp` の値を戻す必要がある．この関数では先頭で `$sp` の値を `20` 減らしたので，関数から返る直前のここでの `addiu` 命令で `20` 増やしている．
- `jr $ra`: `jr` 命令はレジスタを引数に取る．レジスタには上述したプログラム中の場所を表すアドレスがセットされており，次に実行されるのはセットされているアドレスが振られている命令である．`$ra` は _リターンアドレス (return address)_ と呼ばれる特別なアドレスを保持するレジスタである．関数から返るべき先のアドレスがレジスタ `$ra` に関数呼び出し時にセットされる決まりになっている．

## 例2: メモリアクセス

例1のプログラムではレジスタを操作して計算を行う方法を示した．上述したようにレジスタは数が限られているので，より多くの記憶領域が必要になる場合にはメモリに保存すべき情報を読み書きすることになる．以下のプログラムは，メモリアクセスを行う計算を実装した例である．

{% highlight armasm %}
{% include_relative mips/ex02.s %}
{% endhighlight %}

例1のプログラムと異なる部分について説明を加える．

- `li $t0,5`: レジスタ `$t0` に即値 `5` をセットする．
- `sw	$t0, 4($sp)`: `sw` はメモリに値を書き込む命令である．この命令は，レジスタ（ここでは `$t0`）とメモリアドレス（ここでは `4($sp)`）を引数にとり，レジスタの値を指定したメモリアドレスに書き込む．`4($sp)` はメモリアドレスを指定するための式で，現在 `$sp` にセットされているメモリアドレスから `4` バイト先のアドレスを表す．したがって，この命令ではレジスタ `$t0` の値が `$sp + 4` で表されるアドレスに書き込まれる．`$t0` には前の命令で `5` がセットされているはずなので，ここではアドレス `$sp + 4` に値 `5` が書き込まれる．
- `lw	$t1, 4($sp)`: `lw` はメモリから値を読み出す命令である．レジスタとメモリアドレスを引数にとり，このアドレスに保存されている値をレジスタに読みこむ．したがってこの命令ではアドレス `$sp + 4` に保存されている値がレジスタ `$t1` に読み込まれる．この時点ではアドレス `$sp + 4` には1つ前の命令で `5` が書き込まれているはずなので，この命令ではレジスタ `$t1` に `1` がセットされる．
- `li	$v0,1`: レジスタ `$v0` に即値 `1` をセットしている．2命令後の `syscall` で使われる．
- `move $a0,$t1`: レジスタ `$t1` の値をレジスタ `$a0` にコピーする命令である．`$t1` の値は現在 `5` なので，この命令ではレジスタ `$a0` に `5` がセットされる．
- `syscall`: ここでは `$v0` の値が `1` で `$a0` の値が `5` なので，標準出力に `5` が出力される．

このプログラムでは，メモリアクセスの仕方示すために，値 `5` をメモリを経由してレジスタ `$t0` から `$a0` にコピーするなど，意図的に無駄な命令を挟んでいる．メモリアクセスはレジスタへのアクセスに比べて遅いので，必要がなければこのようにプログラムを書くことは無いだろう．

## 例3: 関数呼び出しを伴うプログラム

MiniML4- には関数呼び出しが入っているので，関数呼び出しを MIPS アセンブリ言語でどのように書いたらよいかを理解することは重要である．ここでは関数がどのように実装されているかを学ぼう．

### スタックフレーム

関数呼び出しをアセンブリ言語で実装するにあたっての問題点は，関数の実行に必要な情報をメモリ上にどのように保存しておくかである．関数を呼び出し，計算を実行し，その後元の場所に戻るためには，少なくとも以下の情報を保持する領域をメモリ上に確保しておく必要がある．

- 関数にローカルな変数を保存するための記憶領域とそのアドレス: 関数は局所変数等のための記憶領域を使用して計算を行う．この局所変数のための領域が必要である．また，場合によっては関数に渡そうとしている引数を保持する領域も必要かもしれない．
- 関数呼び出しによって上書きされてしまうレジスタの内容を退避しておく領域: 以下で詳しく述べるが，上で `jr` 命令の説明で少し触れたように，関数を呼び出す際には戻ってくるべき命令のアドレスが特別なレジスタ `$ra` にセットされる．したがって，関数の中で関数を呼び出す場合には，はじめの関数呼び出しの際にセットされた `$ra` の内容をメモリに保存しておく必要がある．（さもなければ，2つ目の関数呼び出しの際に，1つ目の関数が終了した後に実行されるべき命令のアドレスを保持している `$ra` が上書きされてしまう．）`$ra` のような特別なレジスタの値のみならず，それ以外の汎用的なレジスタについても，呼び出し先の関数で上書きされては困るものについては，メモリに退避しておく必要があるだろう．

少しややこしいが，要は関数を正しく実行するためには，ローカルな記憶領域を呼び出しごとに確保する必要があるということである．

このローカルな記憶領域をメモリ上のどこに取るべきかは必ずしも自明ではない．例えばプログラム中で `f` という関数が定義されており，全部で 64 バイト のローカルな記憶領域が必要であったとしよう．「関数 `f` のための 64 バイトの記憶領域」を一箇所メモリ中に確保するだけでは十分ではない．なぜならば，`f` が再帰呼び出しを行っているかもしれないからである．`f` のための単一の記憶領域しか用意されていないとすると，再帰呼び出しのたびに領域が上書きされてしまい，呼び出しごとにローカルな記憶領域を確保するという目的を果たせない．かと言って，1回目の再帰呼び出し，2回目の再帰呼び出し．．．ごとに異なる記憶領域をあらかじめ確保しておくのでは，深い再帰が頻繁には行われない場合にほとんどの領域が無駄になってしまう．

この問題を解決するために通常用いられているのが，関数呼び出しのための記憶領域をスタックを用いて管理する方法である．この方法では，関数の先頭で必要なサイズのローカルな記憶領域をスタックの先頭に push し，関数から返る直前に記憶領域を pop する．これで関数呼び出しごとにローカルな記憶領域を確保することができ，かつ（関数呼び出しが終わったら記憶領域は解放されるので）メモリが無駄になることもない．

関数呼び出しは頻繁に行われることもあるので，スタックの操作やローカル領域へのアクセスが凄まじく複雑になるとプログラムの効率が悪化する．できるだけ簡単にスタック操作を行うために，実際には以下のような方法でローカル領域のスタックが実現されている．

- スタックの先頭のアドレスを常に保持するレジスタを定めておく．（MIPS では `$sp` である．）
- 関数が呼び出されたときに，この呼び出し中に使う記憶領域を確保するために，`$sp` を必要な量だけ動かす．古い `$sp` が保持するアドレスと，新しく `$sp` が保持しているアドレスとの間の領域が，この呼び出しで使用して良い領域ということにする．
- 関数から返る前に `$sp` の値を，確保したサイズ分だけ反対側に動かすことにより，ローカル領域を解放する．

歴史的な事情により，スタックはメモリアドレスの大きい方から小さい方に伸びることが多いようである．したがって，関数呼び出し時には `$sp` の値を減らし，関数から返るときには `$sp` の値を増やすことになる．

各関数呼び出しのローカルな記憶領域が保持されるこのスタックを _コールスタック (call stack)_ と呼ぶ．また，関数呼び出しで確保されるローカルな記憶領域のことを _スタックフレーム (stack frame)_ または _アクティベーションレコード (activation record)_ と呼ぶ．スタックフレームに何を保存するかは，コンパイラに関数呼び出しを実装する上で考えなければならない重要事項の一つである．また，再帰呼び出しが深くなりすぎると _スタックオーバーフロー (stack overflow)_ というメッセージが出ることがあるが，これは関数呼び出しの連鎖が深くなりすぎて，スタック上にスタックフレームを確保することができなくなったときに「スタックに使える領域が溢れて (overflowして) しまった」とユーザに伝えているのである．

### 実例

それでは，実際に関数呼び出しを行っているプログラム例を見てみよう．

{% highlight armasm %}
{% include_relative mips/ex03.s %}
{% endhighlight %}

少し説明を加える．

- `addiu $sp,$sp,-20`: 上記の説明が分かれば，この命令はスタック上に今から使用するスタックフレームを確保していることがわかるであろう．この関数では 20 バイトを使用するので，`$sp` の値を `20` 減らしている．
- `sw	$ra,0($sp)`: このあと関数 `f` を呼び出すので，現在の関数が終わってから返るべき命令のアドレスを保持している `$ra` の値をスタックフレーム上に退避している．スタックフレーム中のどこにどの情報を保存するかはいろいろなデザインがありうるが、今回は `$ra` をアドレス `$sp` に退避することにしよう．
- `jal f`: `jal` 命令は
	lw		$ra,0($sp)
	move	$a0,$v0
	li		$v0,1
	syscall
	addiu	$sp,$sp,20
	jr		$ra
f:
	addiu	$sp,$sp,-4
	addiu	$v0,$a0,2
	addiu	$sp,$sp,4
	jr		$ra

## 例4: 再帰関数

{% highlight armasm %}
{% include_relative mips/ex04.s %}
{% endhighlight %}