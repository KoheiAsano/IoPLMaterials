{% include head.html %}

# MIPS アセンブリ言語入門

ここから先はだんだんハードウェアに近い話が見えてくるので，ここでターゲット言語の MIPS アセンブリ言語について少し勉強しよう．本節では，MIPS アセンブリ言語でプログラムを実際に書いて，その動作を確認する．MIPS アーキテクチャについては[いわゆるパタヘネ本の和訳](https://www.nikkeibp.co.jp/atclpubmkt/book/yy/121400008/)を読まれたい．（買って読んで損はない本である．）

本節の内容は MIPS に詳しい人から見ると不十分だったり不正確だったりする部分が多いかもしれない．改善のための提案には Issue を立ててもらうとありがたい．

ところで，自分が普段使っているマシンで MIPS のコードが直接動く人は多分いない．したがって，本節の内容を実行するには，MIPS のコードを動かすためのシミュレータが欲しい．そのようなシミュレータとして一番お手軽なのは[SPIM](http://spimsimulator.sourceforge.net/)である．これをインストールして使ってもよいのだが，ここでは[ymyzk氏](https://www.ymyzk.com/)による拡張[spim-for-kuis](https://github.com/ymyzk/spim-for-kuis)を勧める．インストール方法は[spim-for-kuis](https://github.com/ymyzk/spim-for-kuis)のページを参照されたい．以下の例も spim-for-kuis での実行例である．

## 例1: レジスタに即値をロードして標準出力に出力する

まずはシンプルなプログラムから見てみよう．以下のプログラムを`ex01.s`として保存して`spim -file ex01.s`を実行してみてほしい．spim-for-kuis が入っていれば，`spim -f-show_stats -show_instructions -file ex01.s` を実行すると，実行された命令と命令数に関する統計情報が出力される．（ARMアセンブリ言語のためのハイライティングしか用意されていなかったので一部構文エラーの警告らしきハイライトが出ているが気にしないこと．）

{% highlight armasm %}
{% include_relative mips/ex01.s %}
{% endhighlight %}

MIPS アセンブリのプログラムでは，各行に以下のいずれかが書かれている．

- 命令: 上の例では `addiu $sp,$sp,-20` のような行は命令である．`$sp`や`-20`等は命令の引数である．命令を実行すると，レジスタやメモリへ情報が読み書きされたり，次に実行する命令が決まったりする．
- ラベル: 上の例では `main:` のような行がラベルである．ラベルはアセンブリ中での場所を表している．次に実行すべき命令を指定するジャンプ命令はラベル名を用いてプログラムのどこにジャンプすべきかを決定することができる．アセンブラによってアセンブリプログラムが機械語に変換されるときには，データや各命令があらかじめ定められた仕様にしたがってバイナリに変換されるが，このときに各命令にもアドレスが付番される．各ラベルはこの変換後のアドレスに変換されてバイナリ中で使われる．（プログラム中の場所にも最終的にアドレスが振られるのだ，ということに注意しておいてほしい．）
- ディレクティブ: `.text` のようにドットで始まる行はディレクティブと呼ばれる．ディレクティブはアセンブリ中のどこにプログラムが書かれているか，どこにデータが書かれているか，このプログラム中でのグローバル関数名はどれかなどの情報をアセンブラに伝える役割がある．この講義の範囲では，深入りせずにおまじないと思っておいてもよい．

一行ずつ内容を説明しよう．

- `.text`: 以降にプログラムが書かれていることを示すディレクティブである．
- `.globl main`: `main` がグローバル関数 `main` の開始場所を表すラベルであることを示すディレクティブである．
- `main:`: ここから関数 `main` の定義が始まることを示すラベルである．
- `addiu  $sp,$sp,-20`: 第1引数 `$sp` に第2引数 `$sp` と第3引数 `-20` の和を書き込む命令である．`$`で始まる名前（例えば`$sp`）は _レジスタ (register)_ と呼ばれる記憶領域を表しており，メモリに比べて数が限られているが読み書きが高速にできる．`$sp` は _スタックポインタ (stack pointer)_ と呼ばれる特別なポインタを保存するためのレジスタである．これについては関数呼び出しの節で詳しく説明するが，ここでは`$sp` の値は (1) 関数定義の先頭で （関数本体によって決まる）一定量減らされ，(2) 関数から戻る前に同じ量だけ増やされる（したがって関数から戻った後の `$sp` の値は関数が呼び出されたときの値と同じである）ことを覚えておいてほしい．
- `li $v0,1`: レジスタ `$v0` に整数定数 `1` を書き込む命令である．アセンブリの文脈では定数のことを _即値 (immediate)_ と呼ぶことが多い．命令 `li` は load immediate から来ているんだと思う．
- `li $a0,20`: 同様にレジスタ `$a0` に即値 `20` を書き込む命令である．
- `syscall`: _システムコール (system call)_ を発行する命令である．`syscall` 命令は標準入出力の操作等を行うための命令で，命令実行時のレジスタ `$a0` とレジスタ `$v0` の値に応じて挙動が変わる．レジスタ `$v0` に `1` がセットされている状態で `syscall` を呼び出すと，標準出力にレジスタ `$a0` の値（すなわちここでは `20`）が出力される．
- `addiu   $sp,$sp,20`: 上で説明したように，関数から返る前に `$sp` の値を戻す必要がある．この関数では先頭で `$sp` の値を `20` 減らしたので，関数から返る直前のここでの `addiu` 命令で `20` 増やしている．
- `jr $ra`: `jr` 命令はレジスタを引数に取る．レジスタには上述したプログラム中の場所を表すアドレスがセットされており，次に実行されるのはセットされているアドレスが振られている命令である．`$ra` は _リターンアドレス (return address)_ と呼ばれる特別なアドレスを保持するレジスタである．関数から返るべき先のアドレスがレジスタ `$ra` に関数呼び出し時にセットされる決まりになっている．

このプログラムでは（`$sp` や `$ra` の話を抜きにすれば）レジスタを操作して計算を行う方法を示した．上述したようにレジスタは数が限られているので，より多くの記憶領域が必要になる場合にはメモリに保存すべき情報を読み書きすることになる．

## 例2: メモリアクセス

{% highlight armasm %}
{% include_relative mips/ex02.s %}
{% endhighlight %}

## 例3: 関数

{% highlight armasm %}
{% include_relative mips/ex03.s %}
{% endhighlight %}

## 例4: 再帰関数

{% highlight armasm %}
{% include_relative mips/ex04.s %}
{% endhighlight %}